##1
기본적인 매커니즘은 앞에서무터 계속 마시는 것. 단 3개 연속해서 마셨을 경우 그 셋중 가장 적은 포도주를 다시 토해낸다.


최근에 몇개씩 연속해서 마셨는지를 기록하는 term을 사용한다. 단 이 term은 토한 포도주가 나올 경우  그 포도주를 기준으로 작성된다
마신게O 안마신게X라 하면

XOOXOXOX의 최근 term은 [2,1,2]

최근 2개의 term이 0~1일 경우 중간 것을 마시는 것이 이득이다
예를 들자면 
XXX -> XOX
XXOX, XOXX -> XOOX

이를 통한 뒤 최근 3개의 term이 2~4인경우 경우의 수를 비교해야 한다 5이상인경우를 비교하지 않는 이유는 
XOOXOOXOX / XOOXOXOOX / XOXOOXOOX 세가지 경우 위의 매커니즘에 의해 결정되었으면 그 값이 최대이기 때문, 6일때는 애초에 하나다.

위의 2개의 term에 의해 걸러지지 않는 경우의 수와 개선안은 다음과 같다

term합 = 2
	XXOOXX
		개선안 : 위의경우 / XOXOOX / XOOXOX 	-> 이 세가지 비교
term합 = 3
	XXOOXOX
	XOXOOXX
	XOXOXOX
		개선안 : 위의경우들 / XOOXOOX 		-> 이 네가지 비교
term합 = 4
	XXOOXOOX
	XOXOXOOX
	XOXOOXOX
	XOOXXOOX
	XOOXOXOX
	XOOXOOXX
		개선안 : 위의 경우들					-> 이 여섯가지 비교

4개 이상의 term을 보고 고려할 필요는 없다 생각했다. 왜냐면 위의 경우의 수로 전부 걸러질 것이라 생각했기에
하지만 안일한 판단이었고 결국 틀렸다..... 이 이상은 너무 노가다성이 짙으므로 버리기로 했다.

이 이후 슬기롭게 토하는 방법을 몇가지 고안하면서 코드를 고쳐봤지만 다시 볼수록 자괴감만 드는 쓰레기만 나왔...

##2 점화식
래준님 회고를 들어가서 길이 보려고 쭉 내리는데 중간에 식이 그냥 점화식어서 다시 이클립스를 켰다.
점화식 세워서 푸니 허무하리만큼 금방 풀었다....
아마 퇴사문제를 점화식이 아닌 시간순으로 풀어서 다이나믹 프로그래밍이 무엇인지에 대한 공부가 부족했던 것 같다.
공부 열심히 할게요.....
